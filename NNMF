import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.util.*;

import Jama.Matrix;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreAnnotations.NamedEntityTagAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.PartOfSpeechAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.SentencesAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.TextAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.TokensAnnotation;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.dcoref.CorefChain;
import edu.stanford.nlp.dcoref.CorefCoreAnnotations.CorefChainAnnotation;
import edu.stanford.nlp.hcoref.CorefCoreAnnotations.CorefMentionsAnnotation;
import edu.stanford.nlp.hcoref.data.Mention;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations;
import edu.stanford.nlp.trees.TreeCoreAnnotations.TreeAnnotation;
import edu.stanford.nlp.util.CoreMap;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class nmf {

	public static StringBuilder stringBuilder = new StringBuilder();
	public static ArrayList<List<String>> csvData= new ArrayList<List<String>>();//data in columns in csv	
	public static ArrayList<List<String>> phrasesTokens= new ArrayList<List<String>>();//data about which tokens are contained in which phrases
	public static ArrayList<List<String>> termsInDocs= new ArrayList<List<String>>();//counts of terms in docs	

	public static void preprocesPhrase(String phrase){
		// creates a StanfordCoreNLP object, with POS tagging, lemmatization, NER, parsing, and coreference resolution 
		List<String> additList= new ArrayList<String>();
		Properties props = new Properties();
		props.setProperty("annotators", "tokenize, ssplit, pos, lemma, ner, parse, dcoref");
		StanfordCoreNLP pipeline = new StanfordCoreNLP(props);

		// create an empty Annotation just with the given text
		Annotation document = new Annotation(phrase);

		// run all Annotators on this text
		pipeline.annotate(document);
	
		// these are all the sentences in this document
		// a CoreMap is essentially a Map that uses class objects as keys and has values with custom types
		List<CoreMap> sentences = document.get(SentencesAnnotation.class);
		
		for(CoreMap sentence: sentences) {
		  // traversing the words in the current sentence
		  // a CoreLabel is a CoreMap with additional token-specific methods
		  for (CoreLabel token: sentence.get(TokensAnnotation.class)) {
		    // this is the text of the token
		    String word = token.get(TextAnnotation.class);
		    // this is the POS tag of the token
		    String pos = token.get(PartOfSpeechAnnotation.class);
		    // this is the NER label of the token
		    String ne = token.get(NamedEntityTagAnnotation.class);
		    
		    System.out.println("Word:("+word+") POS("+pos+") EntityName("+ne+")"+"\n");

			 if( !pos.equalsIgnoreCase("CC")&&
					 !pos.equalsIgnoreCase("CD")&&
					 !pos.equalsIgnoreCase("DT")&&
					 !pos.equalsIgnoreCase("EX")&&
					 !pos.equalsIgnoreCase("FW")&&
					 !pos.equalsIgnoreCase("IN")&&
					 !pos.equalsIgnoreCase("LS")&&
					 !pos.equalsIgnoreCase("MD")&&
					 !pos.equalsIgnoreCase("PDT")&&
					 !pos.equalsIgnoreCase("POS")&&
					 !pos.equalsIgnoreCase("PRP")&&
					 !pos.equalsIgnoreCase("PRP$")&&
					 !pos.equalsIgnoreCase("RP")&&
					 !pos.equalsIgnoreCase("SYM")&&
					 !pos.equalsIgnoreCase("UH")&&
					 !pos.equalsIgnoreCase("TO")&& 
					 !pos.equalsIgnoreCase("WDT")&& 	 
					 !pos.equalsIgnoreCase("WP")&&
					 !pos.equalsIgnoreCase("WP$")&&
					 !pos.equalsIgnoreCase("WRB")&&
					 !pos.equalsIgnoreCase("``"))
		    {additList.add(word);
		    	if(!stringBuilder.toString().contains(word))
		    	stringBuilder.append(word+" ");}
			 
			
           }//check if the word does not exit in the string
		 
		  
		  // phrasesTokens.add(additList);
		  // this is the parse tree of the current sentence
		//  Tree tree = sentence.get(TreeAnnotation.class);
		}	  phrasesTokens.add(additList);
		
	}

	public static List<String> csvFilePhrases(String csvFile){
		// This function should be modified to load all csv files
	 	BufferedReader input = null;
		List<String> phrasesToSend = new ArrayList<String>();
		try 
		{
		    input =  new BufferedReader(new FileReader(csvFile));
		    String line = null; boolean firstLine = true;
		    while (( line = input.readLine()) != null)
		    {  if(!firstLine)
		    {String [] data = line.split("\\|");
		     csvData.add(Arrays.asList(data));}
		    else{firstLine = false;}
		    }
		    }
		catch (Exception ex)
		{ ex.printStackTrace();}
		finally 
		{
		    if(input != null)
		    {
		    	try {input.close();} catch (IOException e) {e.printStackTrace();}
		    }
		}
		for (int i=0;i<csvData.size();i++)
		{phrasesToSend.add((csvData.get(i)).get(0));
		}
		
		return phrasesToSend;
	}
	
	public static void csvTermsInDocs(String csvFile ){
		BufferedReader input = null;
		try 
		{
		    input =  new BufferedReader(new FileReader(csvFile));
		    String line = null; boolean firstLine = true;
		    while (( line = input.readLine()) != null)
		    { 
		    if(!firstLine)
		    {String [] data = line.split(";");
		    termsInDocs.add(Arrays.asList(data));}
		    else{firstLine = false;
		    String [] data = line.split(";");
		   for (int i=0;i<data.length;i++){
		   data[i]=  data[i].substring(1, data[i].length()-1);
		   }  termsInDocs.add(Arrays.asList(data));
		    }}
		}
		catch (Exception ex)
		{
		      ex.printStackTrace();
		}
		finally 
		{
		    if(input != null)
		    {
		    	try {input.close();} catch (IOException e) {e.printStackTrace();}
		    }
		}
	}
		

      public static void writeCsvFile(String fileName,Matrix countsInDocs) {
		    
    	    String header = "phrase|"; //CSV file header
    	 	for(int i=0;i<csvData.get(1).size()-1;i++)
    	 	{header+="cluster"+Integer.toString(i+1)+"|";}
    	 	for (int i=0;i<countsInDocs.getColumnDimension();i++)
    	 	{header+="F"+Integer.toString(i+1);
    	 	if(i!=countsInDocs.getColumnDimension()-1){header+="|";}
    	 	}
    		
		    String delimiter = "|";//Delimiter used in CSV file
		    String separator = "\n";
		
	    	FileWriter fileWriter = null;
		        try {
	            fileWriter = new FileWriter(fileName); //Write the CSV file header
                fileWriter.append(header.toString()); //Add a new line separator after the header
                fileWriter.append(separator); //Write a new object list to the CSV file
          //      System.out.println(csvData.size()+" "+countsInDocs.size());
     	 
                for(int i=0;i<csvData.size();i++)
     		      {fileWriter.append(Integer.toString(i+1)); fileWriter.append('|');
                	for(int j=1;j<csvData.get(i).size();j++)
     		         { fileWriter.append(csvData.get(i).get(j)); fileWriter.append('|'); }
     		       for(int j=0;j<countsInDocs.getColumnDimension();j++)
   		          { fileWriter.append(String.valueOf(countsInDocs.getArray()[i][j]));
   		           if(j!=countsInDocs.getColumnDimension()-1) {fileWriter.append(delimiter);}
   		            else{ fileWriter.append(separator);} 
   		          }
     			}
	        System.out.println("CSV file was created successfully !!!");
	        } catch (Exception e) {
	
	            System.out.println("Error in CsvFileWriter !!!");
	
	            e.printStackTrace();

	        } finally {
	        try {
	        fileWriter.flush();
	             fileWriter.close();
	          } catch (IOException e) {
	             System.out.println("Error while flushing/closing fileWriter!!!");
	                e.printStackTrace();
	            }
	        }
	    }
      
    
      public static Matrix[] GNMF(Matrix D, int r, int rep)
      {double maxEpochs=500;
      double rel=0.0001;
      double CurrentLoss=Double.POSITIVE_INFINITY;
      Matrix[] result=new Matrix[2];
      Matrix[] temp=new Matrix[2];
      for(int i=0;i<rep;i++)
      {
    	  Matrix L0=RandomStart(D.getRowDimension(),r);
    	  Matrix R0=RandomStart(r,D.getColumnDimension());
    	  temp = gnmfLR(D, L0, R0, maxEpochs, rel);
    	  double OldLoss =CurrentLoss;
    	  CurrentLoss = (D.minus(temp[0].times(temp[1]))).normF();  
	      if (CurrentLoss < OldLoss){ System.out.println("Current loss"+CurrentLoss);result=temp;} 
      }
      //order components by magnitude
         double [] mag=null;
         if(r!=1){mag=Magnitude(r,result[0],result[1]);}        
         else{mag=Magnitude(r,result[0].transpose(),result[1].transpose());}
         double[] mag1=Arrays.copyOf(mag, mag.length);
         double[] magcount=new double[mag.length];
         Arrays.sort(mag1);int l=0;  
  	     for(int i=mag1.length-1;i>=0;i--) {magcount[i]=mag1[l];l++;}
  	     mag1=magcount;
 	     for(int i=0;i<mag1.length;i++){for(int j=0;j<mag.length;j++)
 	     {if(mag1[i]==mag[j]){ magcount[i]=j;break;}}}       
 	    String str="";
 	    for(int i=0;i<magcount.length;i++){str+=(mag[(int)magcount[i]])+" ";}
 	    System.out.println("Component norms:"+str);
	    
 	    double [][] l0=new double[result[0].getRowDimension()][result[0].getColumnDimension()]; 
 	    for(int i=0;i<magcount.length;i++)
 	    {for(int j=0;j<result[0].getRowDimension();j++)
 	    	{l0[j][i]= result[0].getArray()[j][(int)magcount[i]];}}
 	    Matrix L00=new Matrix(l0);
 	    
 	   double [][] r0=new double[result[1].getRowDimension()][result[1].getColumnDimension()]; 
 	   
 	 for(int i=0;i<magcount.length;i++)
	    {for(int j=0;j<result[1].getColumnDimension();j++)
	    	{r0[i][j]= result[1].getArray()[(int)magcount[i]][j];}}
	     Matrix R00=new Matrix(r0);
	     result[0]=L00;result[1]=R00;
 	    /*
	    result[0]=matrix(result$L[,mag.order], nrow(D), r)
	    result[1]=matrix(result$R[mag.order,], r, ncol(D))
	    */   
      return result;
      }
      
      public static double[] Magnitude(int r, Matrix L, Matrix R)
      {double[] a=new double[r];
      double[] b=new double[r];
      for(int i=0;i<r;i++)
      {for(int j=0;j<L.getArray().length;j++)  { a[i]+=L.getArray()[j][i]*L.getArray()[j][i];  }
      for(int j=0;j<R.getArray().length;j++)  {b[i]+=R.getArray()[j][i]*R.getArray()[j][i]; }
      a[i]=a[i]*b[i];}
      return a; }
    
      public static Matrix[] gnmfLR(Matrix D,Matrix L,Matrix R,double maxEpochs, double rel){
      	 double eps=Double.parseDouble("1E-9");
      	  Matrix[] list=new Matrix[2];
      	 double CurrentLoss=(D.minus(L.times(R))).normF();
      	 System.out.println("Epoch 0 , loss "+ CurrentLoss);
      	for (int epoch = 1;epoch<=maxEpochs;epoch++) {  //main loop
      	   //  R <- R * (t(L) %*% D + eps) / (crossprod(L) %*% R + eps) 
      //	R =R.arrayTimes((Addition((L.transpose()).times(D),eps)).arrayRightDivide(Addition((L.transpose()).times(L).times(R),eps)));
      	R =R.arrayTimes(Divide((Addition((L.transpose()).times(D),eps)),(Addition((L.transpose()).times(L).times(R),eps))));
     	//  L <- L * (D %*% t(R) + eps)  / (L %*% tcrossprod(R) + eps)
//     	L =L.arrayTimes((Addition(D.times(R.transpose()),eps)).arrayRightDivide(Addition(L.times(R).times(R.transpose()),eps)));
    	L =L.arrayTimes(Divide((Addition(D.times(R.transpose()),eps)),(Addition(L.times(R).times(R.transpose()),eps))));
     	double oldLoss=CurrentLoss;
      	    	 CurrentLoss =(D.minus(L.times(R))).normF();
                 System.out.println("Epoch "+ epoch+", "+CurrentLoss+"\n");
       if(oldLoss>CurrentLoss){
                 if (((oldLoss-CurrentLoss)/CurrentLoss) < rel) { System.out.println(oldLoss+" "+CurrentLoss+" "+oldLoss/CurrentLoss);break;} } 
       } list[0]=L;list[1]=R;  return list; }
      
      public static Matrix[] GKL(Matrix D, int r, int rep)// compute NMF with generalized KL loss
      {double maxEpochs=500;
      double rel=0.0001;
      double CurrentLoss=Double.POSITIVE_INFINITY;
      Matrix[] result=new Matrix[2];
      Matrix[] temp=new Matrix[2];
      for(int i=0;i<rep;i++)
      { Matrix L0=RandomStart(D.getRowDimension(),r);
    	  Matrix R0=RandomStart(r,D.getColumnDimension());
    	  temp = gklLR(D, L0, R0, maxEpochs, rel);
	      double OldLoss =CurrentLoss;
    	  CurrentLoss = gklLoss(D, temp[0], temp[1]);
	      if (CurrentLoss < OldLoss){result=temp;} }
   return result; }
    
      public static Matrix[] gklLR(Matrix D,Matrix L,Matrix R,double maxEpochs, double rel){
     	 double eps=Double.parseDouble("1E-9");
     	  Matrix[] list=new Matrix[2];
     	 double CurrentLoss=gklLoss(D, L, R);
     	 System.out.println("Epoch 0 , loss "+ CurrentLoss+ "\n");
     	for (int epoch = 1;epoch<=maxEpochs;epoch++) {  //main loop
     	   // R =R.arrayTimes( diag(1/(colSums(L) + eps)) %*% (t(L) %*% (D / (L %*% R + eps)) ) );
     //	R =R.arrayTimes(UnitMatrix(Division(Addition(colSums(L),eps),1)).times((L.transpose()).times(D.arrayRightDivide(Addition(L.times(R),eps)))));
     //	L =L.arrayTimes(((D.arrayRightDivide(Addition(L.times(R),eps))).times(R.transpose())).times(UnitMatrix(Division(Addition(rowSums(R),eps),1))));
     		
      	R =R.arrayTimes(UnitMatrix(Division(Addition(colSums(L),eps),1)).times((L.transpose()).times(Divide(D,Addition(L.times(R),eps)))));
     	L =L.arrayTimes(((Divide(D,Addition(L.times(R),eps))).times(R.transpose())).times(UnitMatrix(Division(Addition(rowSums(R),eps),1))));
   
     	// L <- L * ( ((D / (L %*% R + eps)) %*% t(R)) %*% diag(1/(rowSums(R) + eps)) )
     	    	 double oldLoss=CurrentLoss;
     	    	 CurrentLoss =gklLoss(D, L, R);
            	 System.out.println("Epoch "+ epoch+", "+CurrentLoss+"\n");
     	    	        if (oldLoss/CurrentLoss-1 < rel) {break;}  }
     	  list[0]=L;list[1]=R;  return list; }
      
      public static double gklLoss(Matrix D,Matrix L, Matrix R)//compute the generlized KL divergence b/w D and LR
  	{   Matrix WH = L.times(R);	    
        Matrix kl= D.arrayTimes(MatrixLog(Divide(D,WH)));
        double gkl=Sum(kl) - Sum(D) + Sum(WH);
    	return gkl;}
      
  
      // take LR and obtain factorization LSR, where
      // - S is r-by-r diagonal
      // - the columns of L each sum to 1
      // - the rows of R each sum to 1
      public static Matrix[] NMF_LSR(Matrix[] result)
      { Matrix[] result1 =new Matrix[3];
       	Matrix x = colSums(result[0]);
     	Matrix y = rowSums(result[1]);
        Matrix L= result[0].times(UnitMatrix(Division((x),1)));
        Matrix R=(UnitMatrix(Division((y),1))).times(result[1]);
        Matrix S=UnitMatrix(x.arrayTimes(y));
        result1[0]=L;result1[1]=S;result1[1]=R;
    	return result1;}
      
      
	public static void main(String[] args) {
		
		String str="C:\\Users\\Александра\\Desktop\\project\\files";
		File file = new File(str+"\\initial");
		File[] initialfiles = file.listFiles();
	    for(int i=0;i<initialfiles.length;i++)
		{stringBuilder = new StringBuilder();
			csvData= new ArrayList<List<String>>();//data in columns in csv	
			phrasesTokens= new ArrayList<List<String>>();//data about which tokens are contained in which phrases
			termsInDocs= new ArrayList<List<String>>();//counts of terms in docs	
        String name=(String) (initialfiles[i].getName()).subSequence(initialfiles[i].getName().length()-12,initialfiles[i].getName().length()-4);
		String initialfile="C:\\Users\\Александра\\Desktop\\project\\files\\initial\\"+name+".csv";
		String filewithcounts="C:\\Users\\Александра\\Desktop\\project\\files\\counts\\"+name+".csv";
		List<String> phraseList = csvFilePhrases(initialfile);	//	 = "sC:\\Users\\Александра\\Desktop\\Mannheim\\2s\\teampr\\Clustered Questions\\Topic 1-Q1.csv";
			for (int k=0;k<csvData.size();k++)      //!!! look at the results some of the phrases are splitted into several as there is ',' in the phrase
			{for (int j=0;j<csvData.get(k).size();j++)
			{System.out.println((csvData.get(k)).get(j));}
			System.out.println("***");}	
			//preprocess phrases
		    for(int k=0; k< phraseList.size(); k++)
		          {System.out.println("************************\n");
						preprocesPhrase(phraseList.get(k));
				 System.out.println("************************\n");}
			System.out.println(stringBuilder.toString());
			//getFilesFromGilagoAndSaveThem(stringBuilder.toString());
			csvTermsInDocs(filewithcounts);
		    Variant1(name);
		   Variant2FactOfDocs(name,"GKL",5);
	       Variant2FactOfDocs(name,"GNMF",5);
	       Variant3TFactOfDocs(name,"GKL",5);
	        Variant3TFactOfDocs(name,"GNMF",5);
	       Variant2FactOfDocs(name,"GKL",10);
	        Variant2FactOfDocs(name,"GNMF",10);
	        Variant3TFactOfDocs(name,"GKL",10);
	        Variant3TFactOfDocs(name,"GNMF",10);
		}
		
	}
	
	
    public static void Variant1(String name)                                 ///Variant1
    {	//csvTermsInDocs();
//	ArrayList<double[]> countsInDocs= new ArrayList<double[]>();//data in columns in csv	
	
	double[] normal1=new double[termsInDocs.size()-1];//normalization by terms   
	for(int i=1;i<termsInDocs.size();i++){
	double norm=0;for(int j=0;j<termsInDocs.get(1).size()-4;j++)
	{norm+=Math.pow(Double.parseDouble(termsInDocs.get(1).get(j)), 2);}
	norm=Math.pow(norm,0.5);
	normal1[i-1]=norm;}
	double[] normal2=new double[phrasesTokens.size()];
	for(int j=0;j<phrasesTokens.size();j++)
	{normal2[j]=Math.pow(phrasesTokens.get(j).size(),0.5);}
	
	double[][] count=new double[phrasesTokens.size()][termsInDocs.size()-1];
	
	for (int i=0;i<phrasesTokens.size();i++)      //for each phrase
	{ for (int j=0;j<phrasesTokens.get(i).size();j++)  //for each token in the phrase
    	{for (int k=0;k<termsInDocs.get(0).size()-4;k++) //for each word in counts 
		{if(((termsInDocs.get(0)).get(k).toLowerCase().contains((phrasesTokens.get(i)).get(j).toLowerCase()) && (termsInDocs.get(0)).get(k).length()-(phrasesTokens.get(i)).get(j).length()<=3)||((termsInDocs.get(0)).get(k).toLowerCase().equals((phrasesTokens.get(i)).get(j).toLowerCase())))
		{for (int g=0;g<termsInDocs.size()-1;g++)//for each feature
		{count[i][g]+=Double.parseDouble((termsInDocs.get(g+1)).get(k))/(normal1[g]*normal2[i]);}}}}}		
	
	Matrix c=new Matrix(count);
    writeCsvFile("C:\\Users\\Александра\\Desktop\\project\\files\\V1\\V1"+name+".csv", c);	 }
    
    
    public static void Variant2FactOfDocs(String name, String str,int Nr)                                 ///Variant2
    {ArrayList<double[]> countsInDocs= new ArrayList<double[]>();//data in columns in csv	
	
	double[] normal1=new double[termsInDocs.size()-1];//normalization by terms   
	for(int i=1;i<termsInDocs.size();i++){
	double norm=0;for(int j=0;j<termsInDocs.get(1).size()-4;j++)
	{norm+=Math.pow(Double.parseDouble(termsInDocs.get(1).get(j)), 2);}
	norm=Math.pow(norm,0.5);
	normal1[i-1]=norm;}
	double[] normal2=new double[phrasesTokens.size()];
	for(int j=0;j<phrasesTokens.size();j++)
	{normal2[j]=Math.pow(phrasesTokens.get(j).size(),0.5);}

	double[] add;
	for (int i=0;i<phrasesTokens.size();i++)      
	{add=new double[termsInDocs.size()-1];
		for (int j=0;j<phrasesTokens.get(i).size();j++)
    	{for (int k=0;k<termsInDocs.get(0).size()-4;k++)     
		{if(((termsInDocs.get(0)).get(k).toLowerCase().contains((phrasesTokens.get(i)).get(j).toLowerCase()) && (termsInDocs.get(0)).get(k).length()-(phrasesTokens.get(i)).get(j).length()<=3)||((termsInDocs.get(0)).get(k).toLowerCase().equals((phrasesTokens.get(i)).get(j).toLowerCase())))
		{System.out.println("Phrase "+i+":"+(termsInDocs.get(0)).get(k)+k);
		double[] use=new double[termsInDocs.size()-1];
		for (int g=0;g<use.length;g++)
		{use[g]=Double.parseDouble((termsInDocs.get(g+1)).get(k))/(normal1[g]*normal2[i]);
		System.out.println(use[g]);
		add[g]+=use[g];
		}}}}countsInDocs.add(add);}		

    double addit=0;
	for(int i=0;i<countsInDocs.size();i++)
    {for(int j=0;j<countsInDocs.get(i).length;j++)
    {addit+= countsInDocs.get(i)[j];}}
	
	double[][]counts=new double[countsInDocs.size()][countsInDocs.get(0).length];
	for(int i=0;i<countsInDocs.size();i++)
	{for(int j=0;j<countsInDocs.get(0).length;j++)
	{counts[i][j]=countsInDocs.get(i)[j]/addit;}}//normalization
	Matrix D=new Matrix(counts);
	
	Matrix[] D1=null;
	switch(str) {
    case "GKL": D1= GKL(D,Nr,20); break;
	case "GNMF": D1= GNMF(D,Nr,20); break;
	default: break;}
	Matrix[] D2= NMF_LSR(D1);
    writeCsvFile("C:\\Users\\Александра\\Desktop\\project\\files\\V2"+str+Nr+"\\V2"+str+Nr+name+".csv", D2[0]);}
  
    
    public static void Variant3TFactOfDocs(String name, String str,int Nr)                                  ///Variant3
    { double addit=0;
	for(int i=0;i<termsInDocs.size()-1;i++)
    {for(int j=0;j<termsInDocs.get(i).size()-4;j++)
    {addit+=Double.parseDouble(termsInDocs.get(i+1).get(j));}}
	
	double[][]counts=new double[termsInDocs.size()][termsInDocs.get(0).size()-4];
	for(int i=0;i<termsInDocs.size()-1;i++)
    {for(int j=0;j<termsInDocs.get(i).size()-4;j++)
    {counts[i][j]=Double.parseDouble(termsInDocs.get(i+1).get(j))/addit;}}//normalization
	System.out.println((termsInDocs.get(0).size()-4));
	
	Matrix D=new Matrix(counts);
    D=D.transpose();
	Matrix[] D1=null;
	switch(str) {
    case "GKL": D1= GKL(D,Nr,20); break;
	case "GNMF": D1= GNMF(D,Nr,20); break;
	default: break;}
	Matrix[] D2= NMF_LSR(D1);
	Matrix L = D2[0].transpose();
	
	double[][] count=new double[phrasesTokens.size()][L.getRowDimension()];
	for (int i=0;i<phrasesTokens.size();i++)      //for each phrase
	{ 
		for (int j=0;j<phrasesTokens.get(i).size();j++)  //for each token in the phrase
    	{for (int k=0;k<termsInDocs.get(0).size()-4;k++) //for each word in counts 
		{if(((termsInDocs.get(0)).get(k).toLowerCase().contains((phrasesTokens.get(i)).get(j).toLowerCase()) && (termsInDocs.get(0)).get(k).length()-(phrasesTokens.get(i)).get(j).length()<=3)||((termsInDocs.get(0)).get(k).toLowerCase().equals((phrasesTokens.get(i)).get(j).toLowerCase())))
		{for (int g=0;g<L.getRowDimension();g++)//for each feature
		{count[i][g]+=L.getArray()[g][k];}}}}}		
	Matrix a=new Matrix(count);
    writeCsvFile("C:\\Users\\Александра\\Desktop\\project\\files\\V3"+str+Nr+"\\V3"+str+Nr+name+".csv",a);
 }
    
    public static Matrix colSums(Matrix D)//column sums
    {System.out.println(D.getColumnDimension());
    	double[][]a=new double[D.getColumnDimension()][1];
  	  Matrix A=new Matrix(a);
    for(int i=0;i<D.getRowDimension();i++)
    {for(int j=0;j<D.getColumnDimension();j++)
    {A.getArray()[j][0]+=D.getArray()[i][j];
    }}return A;}
    
    public static Matrix rowSums(Matrix D)//row sums
    {double[][]a=new double[D.getRowDimension()][1];
  	  Matrix A=new Matrix(a);
     for(int i=0;i<D.getRowDimension();i++)
        {for(int j=0;j<D.getColumnDimension();j++)
          {A.getArray()[i][0]+=D.getArray()[i][j]; }}
	  return A;}
   
    public static Matrix Addition(Matrix A,double eps)//A+eps
    {for(int i=0;i<A.getRowDimension();i++)
    {for(int j=0;j<A.getColumnDimension();j++)
    {A.getArray()[i][j]=A.getArray()[i][j]+eps;}}
  	  return A; }
    
    public static Matrix Division(Matrix A,double eps)//eps/A
    {for(int i=0;i<A.getRowDimension();i++)
    {for(int j=0;j<A.getColumnDimension();j++)
    {A.getArray()[i][j]=eps/A.getArray()[i][j];}}
  	  return A; }
   
    public static Matrix Divide(Matrix A,Matrix B)//A/B
    {double[][] vals = new double [A.getRowDimension()][A.getColumnDimension()];
  	  Matrix C=new Matrix(vals);
  	  for(int i=0;i<A.getRowDimension();i++)
  	  {for(int j=0;j<A.getColumnDimension();j++)
  	  {if(B.getArray()[i][j]!=0)
  	  {C.getArray()[i][j]=A.getArray()[i][j]/B.getArray()[i][j];} else {C.getArray()[i][j]=0;}
  	  }}
  	  return C;}
    
    public static Matrix MatrixLog(Matrix A)//(log(A))
    {double[][] vals = new double [A.getRowDimension()][A.getColumnDimension()];
  	  Matrix C=new Matrix(vals);
  	  for(int i=0;i<A.getRowDimension();i++)
  	  {for(int j=0;j<A.getColumnDimension();j++)
  	  {if(A.getArray()[i][j]!=0)
  	  {C.getArray()[i][j]=Math.log(A.getArray()[i][j]);} else {C.getArray()[i][j]=0;}}}
  	  return C;}
   
    public static double Sum(Matrix A)//sum of all elements
    {double sum=0;
  	  for(int i=0;i<A.getRowDimension();i++)
    {for(int j=0;j<A.getColumnDimension();j++)
    {sum+=A.getArray()[i][j];}}
    return sum;}
    
    public static Matrix UnitMatrix(Matrix vector)//send vector, get I*vector matrix
    {int size=vector.getRowDimension();
  	  double[][]a=new double[size][size];
      for(int i=0;i<size;i++)
      {for(int j=0;j<size;j++)
      {if(i==j){a[i][j]=vector.getArray()[i][0];}
      else{a[i][j]=0;}}  }
  	  Matrix A=new Matrix(a);
  	  return A;}
    
    public static Matrix RandomStart(int rNum,int cNum)//random initialization
    {double[][]a=new double[rNum][cNum];
    Random randomno = new Random();
    for(int i=0;i<rNum;i++)
      {for(int j=0;j<cNum;j++)
      {a[i][j]= randomno.nextDouble();}}
  	  Matrix A=new Matrix(a);
  	  return A; }

}
